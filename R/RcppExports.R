# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @name bipartiteMatch
#' @title Bipartite matching with the Hungarian algorithm 
#' @description Solves weighted bipartite matching on a cost matrix (i.e. distance) using the hungarian algorithm
#' @details This is a copy/clone of the code developed by Cong Ma and the Rcpp wrapper developed by Justin Silverman released in the RcppHungarian package.
#' @param costMatrix a cost matrix on which to match, note that the best matches will minimize the diagonal, thus distances are appropriate.
#' @return List with cost and pairings, pairings are given as an nx2 matrix giving edges that are metched.
#' @export
bipartiteMatch <- function(costMatrix) {
    .Call(`_tlearn_bipartiteMatch`, costMatrix)
}

#' @name Rcpp_bls
#' @title Bounded least squares
#' @description Solve \code{a \%*\% x = b} using sequential coordinate descent bounded least squares, where \code{a} is a square matrix and \code{x} and \code{b} are vectors.
#' @details See \code{cls} R function documentation for a more convenient interface and details. This function should only be used when speed is paramount. Fields are not nullable.
#' @param x required initial numeric vector of doubles for x, may simply specify a vector of ones
#' @param a square numeric dense matrix of doubles containing the coefficients of the linear system
#' @param b numeric vector of doubles giving the right-hand side of the linear system
#' @param maxit integer, maximum number of iterations for least squares sequential coordinate descent
#' @param tol double, tolerance for convergence of the least squares sequential coordinate descent solver
#' @param min double minimum permitted value, use zero for NMF
#' @param max double, maximum permitted value, use a large value to avoid an upper bound constraint
#' @param fixed a vector of 0 or 1 corresponding to "x" indicating if values in the supplied "x" vector should be fixed (i.e. not updated). To fix, specify 1, otherwise specify 0. If not fixing any values, specify a vector of zeros of length x.
#' @return x vector of least squares solution
#' @export
Rcpp_bls <- function(x, a, b, maxit, tol, min, max, fixed) {
    .Call(`_tlearn_Rcpp_bls`, x, a, b, maxit, tol, min, max, fixed)
}

#' @name Rcpp_multinomial_bls
#' @title Multinomial-constrained bounded least squares
#' @description Solve \code{a \%*\% x = b} using sequential coordinate descent bounded least squares, where \code{a} is a square matrix and \code{x} and \code{b} are vectors and \code{x} is constrained to values in a specified multinomial distribution
#' @details See \code{cls} R function documentation for a more convenient interface and details. This function should only be used when speed is paramount. Fields are not nullable. \code{multinomial_bls} first fits a simple bounded model, then takes the largest value and fixes it to the closest value in the multinomial distribution. This process is repeated until until all values have been constrained.
#' @param x required initial numeric vector of doubles for x, may simply specify a vector of ones
#' @param a square numeric dense matrix of doubles containing the coefficients of the linear system
#' @param b numeric vector of doubles giving the right-hand side of the linear system
#' @param maxit integer, maximum number of iterations for least squares sequential coordinate descent
#' @param tol double, tolerance for convergence of the least squares sequential coordinate descent solver
#' @param min double minimum permitted value, use zero for NMF
#' @param max double, maximum permitted value, use a large value to avoid an upper bound constraint
#' @param fixed a vector of 0 or 1 corresponding to "x" indicating if values in the supplied "x" vector should be fixed (i.e. not updated). To fix, specify 1, otherwise specify 0. If not fixing any values, specify a vector of zeros of length x.
#' @param values numeric array, either a vector of c(0, 0) to ignore multinomial constraints, or a vector of permitted values in the projection. Must be specified in ascending order and be of at least length 2 and strictly in the range [min, max].
#' @return x vector of least squares solution
#' @export
Rcpp_multinomial_bls <- function(x, a, b, maxit, tol, min, max, values, fixed) {
    .Call(`_tlearn_Rcpp_multinomial_bls`, x, a, b, maxit, tol, min, max, values, fixed)
}

#' @name Rcpp_L0_bls
#' @title L0 and/or multinomial-constrained bounded least squares
#' @description Solve \code{a \%*\% x = b} using sequential coordinate descent bounded least squares, where \code{a} is a square matrix and \code{x} and \code{b} are vectors and \code{x} is constrained to values in a specified multinomial distribution and the cardinality of x is truncated to specified L0 value.
#' @details See \code{cls} R function documentation for a more convenient interface and details. This function should only be used when speed is paramount. Fields are not nullable. \code{multinomial_bls} first fits a simple bounded model, then takes the largest value and fixes it to the closest value in the multinomial distribution. This process is repeated until until all values have been constrained. L0 regularization is applied to the \code{multinomial_bls} fit by incrementally imposing the penalty and refitting the model with each step into the full truncation.
#' @param x required initial numeric vector of doubles for x, may simply specify a vector of ones
#' @param a square numeric dense matrix of doubles containing the coefficients of the linear system
#' @param b numeric vector of doubles giving the right-hand side of the linear system
#' @param maxit integer, maximum number of iterations for least squares sequential coordinate descent
#' @param tol double, tolerance for convergence of the least squares sequential coordinate descent solver
#' @param min double minimum permitted value, use zero for NMF
#' @param max double, maximum permitted value, use a large value to avoid an upper bound constraint
#' @param fixed a vector of 0 or 1 corresponding to "x" indicating if values in the supplied "x" vector should be fixed (i.e. not updated). To fix, specify 1, otherwise specify 0. If not fixing any values, specify a vector of zeros of length x.
#' @param values numeric array, either a vector of c(0, 0) to ignore multinomial constraints, or a vector of permitted values in the projection. Must be specified in ascending order and be of at least length 2 and strictly in the range [min, max].
#' @param L0 the cardinality or L0 truncation to impose on x. This will be incrementally enforced.
#' @return x vector of least squares solution
#' @export
Rcpp_L0_bls <- function(x, a, b, maxit, tol, min, max, values, L0, fixed) {
    .Call(`_tlearn_Rcpp_L0_bls`, x, a, b, maxit, tol, min, max, values, L0, fixed)
}

Rcpp_cls <- function(x, a, b, maxit, tol, min, max, values, L0) {
    .Call(`_tlearn_Rcpp_cls`, x, a, b, maxit, tol, min, max, values, L0)
}

#' @name Rcpp_Loss
#' @title Loss of a factorization
#' @description Calculates the loss of "A - wdh" with optional weights and one-sided L1, L2, and PE regualrizations, parallelized across columns of "A", where "A" is dense.
#' @details This function is for cases where "A" is dense. Use the R function "error" for a more accessible interface and details. This is the Rcpp interface for the fastest possible implementation.
#' @param w matrix of features x factors (rows x columns)
#' @param d vector giving scaling diagonal between w and h, if no scaling specify a vector of 1s of the same length as the number of factors (i.e. number of columns in "w")
#' @param h matrix of factors x samples (rows x columns)
#' @param A dense matrix of features x samples (rows x columns)
#' @param A_weights weighting matrix for the loss, the function will not apply any weighting matrix that is not of the same dimensions as "A". For instance, if no weights are to be applied, simply specify a dense matrix of 1 with 1 row and column.
#' @param w_L1 L1/LASSO regularization on w
#' @param w_L2 L2/Ridge regression on w
#' @param w_PE PE/Pattern Extraction regularization on w
#' @param h_L1 L1/LASSO regularization on h
#' @param h_L2 L2/Ridge regression on h
#' @param h_PE PE/Pattern Extraction regularization on h
#' @param loss_type integer, 1 for "mse" or any other value for "mae"
#' @param threads number of threads for OpenMP parallelization, set to 0 to let OpenMP decide and use all available threads
#' @return loss of the factorization (as mse or mae)
#' @export
Rcpp_Loss <- function(w, d, h, A, A_weights, w_L1, w_L2, w_PE, h_L1, h_L2, h_PE, loss_type, threads) {
    .Call(`_tlearn_Rcpp_Loss`, w, d, h, A, A_weights, w_L1, w_L2, w_PE, h_L1, h_L2, h_PE, loss_type, threads)
}

#' @name Rcpp_SpLoss
#' @title Loss of a factorization
#' @description Calculates the loss of "A - wdh" with optional weights and one-sided L1, L2, and PE regualrizations, parallelized across columns of "A", where "A" is sparse.
#' @details This function is for cases where "A" is a sparse matrix. Use the R function "error" for a more accessible interface and details. This is the Rcpp interface for the fastest possible implementation.
#' @param w matrix of features x factors (rows x columns)
#' @param d vector giving scaling diagonal between w and h, if no scaling specify a vector of 1s of the same length as the number of factors (i.e. number of columns in "w")
#' @param h matrix of factors x samples (rows x columns)
#' @param A sparse matrix of features x samples (rows x columns)
#' @param A_weights sparse weighting matrix for the loss, the function will not apply any weighting matrix that is not of the same dimensions as "A". For instance, if no weights are to be applied, simply specify a dense matrix of 1 with 1 row and column (of course, in sparse format).
#' @param w_L1 L1/LASSO regularization on w
#' @param w_L2 L2/Ridge regression on w
#' @param w_PE PE/Pattern Extraction regularization on w
#' @param h_L1 L1/LASSO regularization on h
#' @param h_L2 L2/Ridge regression on h
#' @param h_PE PE/Pattern Extraction regularization on h
#' @param loss_type integer, 1 for "mse" or any other value for "mae"
#' @param threads number of threads for OpenMP parallelization, set to 0 to let OpenMP decide and use all available threads
#' @return loss of the factorization (as mse or mae)
#' @export
Rcpp_SpLoss <- function(w, d, h, A, A_weights, w_L1, w_L2, w_PE, h_L1, h_L2, h_PE, loss_type) {
    .Call(`_tlearn_Rcpp_SpLoss`, w, d, h, A, A_weights, w_L1, w_L2, w_PE, h_L1, h_L2, h_PE, loss_type)
}

#' @name Rcpp_LossSample
#' @title Loss of a factorization for each sample
#' @description Calculates the loss of "A - wdh" for each sample, where "A" is dense.
#' @details This function is for cases where "A" is dense. Use the R function "errorSample" for a more accessible interface and details. This is the Rcpp interface for the fastest possible implementation.
#' @param w matrix of features x factors (rows x columns)
#' @param d vector giving scaling diagonal between w and h, if no scaling specify a vector of 1s of the same length as the number of factors (i.e. number of columns in "w")
#' @param h matrix of factors x samples (rows x columns)
#' @param A dense matrix of features x samples (rows x columns)
#' @param loss_type integer, 1 for "mse" or any other value for "mae"
#' @param threads number of threads for OpenMP parallelization, set to 0 to let OpenMP decide and use all available threads
#' @return loss of the factorization for each sample (as mse or mae)
#' @export
Rcpp_LossSample <- function(w, d, h, A, loss_type, threads) {
    .Call(`_tlearn_Rcpp_LossSample`, w, d, h, A, loss_type, threads)
}

#' @name Rcpp_SpLossSample
#' @title Loss of a factorization for each sample
#' @description Calculates the loss of "A - wdh" for each sample, where "A" is sparse.
#' @details This function is for cases where "A" is sparse. Use the R function "errorSample" for a more accessible interface and details. This is the Rcpp interface for the fastest possible implementation.
#' @param w matrix of features x factors (rows x columns)
#' @param d vector giving scaling diagonal between w and h, if no scaling specify a vector of 1s of the same length as the number of factors (i.e. number of columns in "w")
#' @param h matrix of factors x samples (rows x columns)
#' @param A sparse matrix of features x samples (rows x columns)
#' @param loss_type integer, 1 for "mse" or any other value for "mae"
#' @param threads number of threads for OpenMP parallelization, set to 0 to let OpenMP decide and use all available threads
#' @return loss of the factorization for each sample (as mse or mae)
#' @export
Rcpp_SpLossSample <- function(w, d, h, A, loss_type, threads) {
    .Call(`_tlearn_Rcpp_SpLossSample`, w, d, h, A, loss_type, threads)
}

#' @name Rcpp_Solve
#' @title Solve A = WH for H
#' @description See "tlearn" R function documentation for practical details. This function requires full specification as described below. Fields are not nullable.
#' @param h initial sample embeddings model (as factors x samples)
#' @param wt transposed feature model dense matrix (as factors x features, note transposition)
#' @param A features x samples matrix in dense format
#' @param threads integer, threads number of threads to use, or 0 to use all threads as determined by OpenMP
#' @param L0 integer, L0 sample truncation
#' @param L1 double, L1/Lasso regularization
#' @param L2 double, L2/ridge regression
#' @param PE double, pattern extraction regularization
#' @param values numeric array, either a vector of c(0, 0) to ignore multinomial constraints, or a vector of permitted values in the projection
#' @param maxit integer, number of iterations permitted for the sequential coordinate descent least squares solver
#' @param tol double, tolerance for convergence of sequential coordinate descent least squares solver
#' @param min double minimum permitted value in model (usually 0)
#' @param max double maximum permitted value in model (set to very large value to avoid an upper bound)
#' @return h matrix of sample embeddings
#' @export
Rcpp_Solve <- function(h, wt, A, threads, L0, L1, L2, PE, values, maxit, tol, min, max) {
    .Call(`_tlearn_Rcpp_Solve`, h, wt, A, threads, L0, L1, L2, PE, values, maxit, tol, min, max)
}

#' @name Rcpp_SpSolve
#' @title Solve <SpMat>A = WH for H
#' @description See "tlearn" R function documentation for practical details. This function requires full specification as described below. Fields are not nullable.
#' @param h initial sample embeddings model (as factors x samples)
#' @param wt transposed feature model dense matrix (as factors x features, note transposition)
#' @param A sparse matrix of features x samples
#' @param threads integer, threads number of threads to use, or 0 to use all threads as determined by OpenMP
#' @param L0 integer, L0 sample truncation
#' @param L1 double, L1/Lasso regularization
#' @param L2 double, L2/ridge regression
#' @param PE double, pattern extraction regularization
#' @param values numeric array, either a vector of c(0, 0) to ignore multinomial constraints, or a vector of permitted values in the projection
#' @param maxit integer, number of iterations permitted for the sequential coordinate descent least squares solver
#' @param tol double, tolerance for convergence of sequential coordinate descent least squares solver
#' @param min double minimum permitted value in model (usually 0)
#' @param max double maximum permitted value in model (set to very large value to avoid an upper bound)
#' @return h matrix of sample embeddings
#' @export
#' @export
Rcpp_SpSolve <- function(h, wt, A, threads, L0, L1, L2, PE, values, maxit, tol, min, max) {
    .Call(`_tlearn_Rcpp_SpSolve`, h, wt, A, threads, L0, L1, L2, PE, values, maxit, tol, min, max)
}

#' @name Rcpp_WSolve
#' @title Solve A = WH for H with weighting
#' @description See "tlearn" R function documentation for practical details. This function requires full specification as described below. Fields are not nullable.
#' @param h initial sample embeddings model (as factors x samples)
#' @param wt transposed feature model dense matrix (as factors x features, note transposition)
#' @param A dense matrix of features x samples
#' @param A_weights dense matrix of weights for features x samples
#' @param threads integer, threads number of threads to use, or 0 to use all threads as determined by OpenMP
#' @param L0 integer, L0 sample truncation
#' @param L1 double, L1/Lasso regularization
#' @param L2 double, L2/ridge regression
#' @param PE double, pattern extraction regularization
#' @param values numeric array, either a vector of c(0, 0) to ignore multinomial constraints, or a vector of permitted values in the projection
#' @param maxit integer, number of iterations permitted for the sequential coordinate descent least squares solver
#' @param tol double, tolerance for convergence of sequential coordinate descent least squares solver
#' @param min double minimum permitted value in model (usually 0)
#' @param max double maximum permitted value in model (set to very large value to avoid an upper bound)
#' @return h matrix of sample embeddings
#' @export
Rcpp_WSolve <- function(h, wt, A, A_weights, threads, L0, L1, L2, PE, values, maxit, tol, min, max) {
    .Call(`_tlearn_Rcpp_WSolve`, h, wt, A, A_weights, threads, L0, L1, L2, PE, values, maxit, tol, min, max)
}

#' @name Rcpp_SpWSolve
#' @title Solve <SpMat>A = WH for H with weighting
#' @description See "tlearn" R function documentation for practical details. This function requires full specification as described below. Fields are not nullable.
#' @param h initial sample embeddings model (as factors x samples)
#' @param wt transposed feature model dense matrix (as factors x features, note transposition)
#' @param A sparse matrix of features x samples
#' @param A_weights sparse matrix of weights for features x samples
#' @param threads integer, threads number of threads to use, or 0 to use all threads as determined by OpenMP
#' @param L0 integer, L0 sample truncation
#' @param L1 double, L1/Lasso regularization
#' @param L2 double, L2/ridge regression
#' @param PE double, pattern extraction regularization
#' @param values numeric array, either a vector of c(0, 0) to ignore multinomial constraints, or a vector of permitted values in the projection
#' @param maxit integer, number of iterations permitted for the sequential coordinate descent least squares solver
#' @param tol double, tolerance for convergence of sequential coordinate descent least squares solver
#' @param min double minimum permitted value in model (usually 0)
#' @param max double maximum permitted value in model (set to very large value to avoid an upper bound)
#' @return h matrix of sample embeddings
#' @export
Rcpp_SpWSolve <- function(h, wt, A, A_weights, threads, L0, L1, L2, PE, values, maxit, tol, min, max) {
    .Call(`_tlearn_Rcpp_SpWSolve`, h, wt, A, A_weights, threads, L0, L1, L2, PE, values, maxit, tol, min, max)
}

